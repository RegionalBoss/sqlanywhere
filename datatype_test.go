package sqlanywhere

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"reflect"
	"testing"
	"time"

	"github.com/google/uuid"
)

const CreateDataTypes = `
create table datatypes (

	//UUID
	//Used for primary key or other unique column.
	//Generated by NEWID() function. Eg: create table x( pk UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(), ...)
	//SQL Anywhere automatically converts UNIQUEIDENTIFIER values between string and binary values as needed.
	//UNIQUEIDENTIFIER values are stored as BINARY(16), but are described to client applications as BINARY(36).
	//This description ensures that if the client fetches the value as a string, it has allocated enough space for the result.
	a_uniqueidentifier  uniqueidentifier primary key default newid(),

	//numbers
	a_bigint    		bigint, 			//8 bytes
	a_bigint_unsigned	unsigned bigint, 	//8 bytes
	a_bit       		bit default 0, 		//1 byte
	a_decimal   		decimal(30,6), 		//byte estimate: 2 + int( (before + 1)/2 ) + int( (after + 1)/2 )
	a_double    		double, 			//8 bytes
	a_real      		real, 				//4 bytes
	a_float_4   		float(24), 			//precision 1-24 = 4 bytes
	a_float_8   		float(53), 			//precision 25-53 = 8 bytes
	a_integer   		integer,    		//4 bytes, alias INT
	a_integer_unsigned 	unsigned integer, 	//4 bytes 
	a_smallint  		smallint, 			//2 bytes
	a_smallint_unsigned unsigned smallint, 	//2 bytes
	a_tinyint   		tinyint, 			//1 byte
	a_tinyint_unsigned 	unsigned tinyint, 	//1 byte


	//dates and times
	//format depends on default datetime
	a_date      date, 		//4 bytes 0000-00-00
	a_timestamp timestamp, 	//8 bytes 0000-00-00 00:00:00.000000, alias DATETIME
	a_time      time, 		//8 bytes 00:00:00.000000
	a_timestamp_with_timezone timestamp with time zone, //10 bytes 00:00:00.000000±00:00

	//strings
	//Character data types are used to store strings of letters, numbers, and other symbols.
	//SQL Anywhere provides two classes of character data types and some domains defined using those types.
	//CHAR, VARCHAR, LONG VARCHAR   Character data stored in a single- or multibyte character set, often 
	//chosen to correspond most closely to the primary language or languages stored in the database.
	//NCHAR, NVARCHAR, LONG NVARCHAR   Character data stored in Unicode's UTF-8 encoding. 
	//All Unicode code points can be stored using these types, regardless of the primary language or 
	//languages stored in the database.
	//TEXT, UNIQUEIDENTIFIERSTR, XML   Domains based on other character data types.
	//All character data values are stored in the same manner.
	//By default, values up to 128 bytes are stored in a single piece.
	//Values longer than 128 bytes are stored with a 4-byte prefix kept
	//locally on the database page and the full value stored in one or
	//more other database pages.
	//CHAR & NCHAR behave like VARCHAR & NVARCHAR, respectively, though they are different types
	//UNIQUEIDENTIFIERSTR = CHAR(36), TEXT = LONG VARCHAR, NTEXT = LONG NVARCHAR
	//For nvarchar, the maximum number of letters depends on the content, eg, english text uses 1 byte per character, 
	//japanese text uses 3-4 bytes per character. The minimum is 327676/4 (>80,000 runes), but typically many more

	a_varchar_10_bytes 		varchar(10), 			//<=10 bytes (of 32767 max) of character encoded data
	a_varchar_10_letters   	varchar(10 character), 	//<=10 characters, byte storage is charset dependant, eg, utf8 = 40 bytes
	a_varchar_long 			long varchar, 			//<=2Gb of character data, alias TEXT
	a_nvarchar_10_letters   nvarchar(10), 			//<= 327676 bytes of utf8. 
	a_nvarchar_long     	long nvarchar, 			//<= 2Gb of utf8, alias NTEXT
	a_xml               	xml, 					//<= 2Gb of XML

	//binary data types
	a_binary_10_bytes   binary(10), 	//up to 32767 bytes. Same as VARBINARY
	a_binary_long       long binary, 	//up to 2Gb

	//bit arrays
	a_varbit_10_bits    varbit(10),		//bit array up to 32766 bits long
	a_varbit_long       long varbit, 	//bit array of arbitrary length
)
`
const DropDataTypes = "drop table if exists datatypes"

func dbTestDataTypes(targetdb *sql.DB, t *testing.T) {

	tx, err := targetdb.Begin()
	if err != nil {
		t.Fatal(err)
	}
	if _, err := tx.Exec(CreateDataTypes); err != nil {
		t.Fatal(err)
	}
	defer func() {
		if _, err := tx.Exec(DropDataTypes); err != nil {
			t.Error(err)
		}
		if err := tx.Commit(); err != nil {
			t.Errorf("did not commit transaction: %v", err)
		}
	}()

	insert := func(col string, val driver.Value) {
		id := uuid.New()
		sql := fmt.Sprintf("insert into datatypes (a_uniqueidentifier, %s) values (?, ?)", col)
		if _, err := tx.Exec(sql, id, val); err != nil {
			t.Fatalf("did not insert %s: %T(%#v): %s", col, val, val, err)
		}

		var got driver.Value
		row := tx.QueryRow(fmt.Sprintf("select %s from datatypes where a_uniqueidentifier = ?", col), id)
		if err := row.Scan(&got); err != nil {
			t.Fatal(err)
		}
		if !reflect.DeepEqual(val, got) {
			t.Fatalf("did not retrieve %s: want %T(%v), got %T(%v)", col, val, val, got, got)
		}
	}

	insert("a_bigint", int64(64))
	insert("a_bigint_unsigned", uint64(64))
	insert("a_bit", true)
	insert("a_double", float64(123.456))
	insert("a_decimal", "999999999999999999999999.999999") //string, stored as decimal
	insert("a_float_8", float64(234.567))
	insert("a_integer", int32(123))
	insert("a_integer_unsigned", uint32(123))
	insert("a_smallint", int16(123))
	insert("a_smallint_unsigned", uint16(123))
	insert("a_tinyint", uint8(64)) //tinyint always unsigned
	insert("a_tinyint_unsigned", uint8(64))
	insert("a_real", float32(123.456))
	insert("a_float_4", float32(234.567))
	insert("a_integer", int32(-123)) //negative
	insert("a_timestamp_with_timezone", "2016-11-20 10:00:00.000+12:00")

	ts, _ := time.Parse(DateTime, "2016-11-19 22:18:58")
	insert("a_timestamp", ts)
	dt, _ := time.Parse(Date, "2016-11-19")
	insert("a_date", dt)
	tm, _ := time.Parse(Time, "22:18:58")
	insert("a_time", tm)

	insert("a_varchar_10_bytes", "Hello Rain")
	insert("a_varchar_10_letters", "Hello Rain")
	insert("a_varchar_long", "hello there you long piece of text you")
	insert("a_xml", "<man type=\"adult\"><name>Rain</name></man>")
	insert("a_nvarchar_10_letters", "Hello Rain")
	insert("a_nvarchar_long", "Hello there!")
	insert("a_varchar_10_bytes", "")

	insert("a_varchar_10_letters", "Hello 日本")
	insert("a_nvarchar_10_letters", "Hello 日本")
	insert("a_nvarchar_long", "Hello 日本")

	insert("a_binary_10_bytes", []byte("0123456789"))
	insert("a_binary_long", []byte("Hello Long Binary 日本"))
	insert("a_binary_long", []byte{})
	insert("a_varbit_10_bits", "1000000001")
	insert("a_varbit_long", "1000000001")
}
